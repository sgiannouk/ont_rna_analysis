###Stavros Giannoukakos### 

### conda activate pycoQC

#Version of the program
__version__ = "0.1.0"

import argparse
import subprocess
import shutil, time, glob, sys, os, re

raw_data_dir =  "/shared/projects/silvia_ont_umc/all_rna_sample2/20190604_1354_MN29521_FAK43904_3bcfbe09"
# raw_data_dir =  "/shared/projects/silvia_ont_umc/mrna_sample3/sample_3/20190611_1508_MN29521_FAK43817_4ea54369/"
refGenomeGRCh38 = "~/playground/progs/reference_files/reference_genome/GRCh38_primAssembly/GRCh38_primary_assembly_genome.fa"
refTranscGRCh38 = "~/playground/progs/reference_files/reference_transcriptome/ensembl_cdna_ncrna/GRCh38_cdna_ncrna.fasta"
refAnnot = "~/playground/progs/reference_files/gene_annotation/gencode.v29.primary_assembly.annotation.gtf"

usage = "ont_analysis [options]"
epilog = " -- June 2019 | Stavros Giannoukakos -- "
description = "DESCRIPTION"

parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter, usage=usage, description=description, epilog=epilog)
# Number of threads/CPUs to be used
parser.add_argument('-th', '--threads', dest='threads', default=20, metavar='', 
                	help="Number of threads to be used in the analysis")
# Display the version of the pipeline 
parser.add_argument('-v', '--version', action='version', version='%(prog)s {0}'.format(__version__))
# Get the options and return them
args = parser.parse_args()

current_dir = os.getcwd()

# Main folder hosting the analysis
analysis_dir = os.path.join(current_dir, "analysis")
prepr_dir = os.path.join(analysis_dir, "preprocessed_data")
alignments_dir = os.path.join(analysis_dir, "alignments")
reports_dir = os.path.join(analysis_dir, "reports")



def quality_control():
	if not os.path.exists(reports_dir): os.makedirs(reports_dir)

	seq_summary_file = [sum_file for sum_file in glob.glob(os.path.join(raw_data_dir, "*/*_sequencing_summary.txt"))][0]
	sample_id = raw_data_dir.split("/")[4].split("_")[-1]
	
	pycoQC = " ".join([
	"pycoQC",  # Call pycoQC
	"--summary_file", seq_summary_file,  # Input of <sequencing_summary> generated by Albacore1.0.0 / Guppy 2.1.3+
	"--html_outfile", os.path.join(reports_dir, "{0}_pycoQC_report.html".format(sample_id)),  # Create the report in the reports directory
	"--title", "\"{0} quality control report\"".format(sample_id),  # A title to be used in the html report
	"--verbose_level 0",
	"2>>", os.path.join(reports_dir, "pycoQC-report.txt")])
	subprocess.run(pycoQC, shell=True)

	nanoPlot = " ".join([
	"NanoPlot",  # Call pycoQC
	"--threads", str(args.threads),  # Number of threads to be used by the script
	"--summary", seq_summary_file,  # Input of <sequencing_summary> generated by Albacore1.0.0 / Guppy 2.1.3+
	"--color saddlebrown",  # Color for the plots
	"--colormap PuBuGn",  # Colormap for the heatmap
	"--prefix", os.path.join(reports_dir, "{0}_".format(sample_id)),  # Create the report in the reports directory
	"--format png",  # Output format of the plots
	"--dpi 900", # Set the dpi for saving images in high resolution
	"2>>", os.path.join(reports_dir, "nanoPlot_report.txt")])
	subprocess.run(nanoPlot, shell=True)
	return

def preprocessing_raw_data():
	if not os.path.exists(prepr_dir): os.makedirs(prepr_dir)
	raw_data = [sum_file for sum_file in glob.glob(os.path.join(raw_data_dir, "fastq_pass/*.fastq.gz"))]	

	for file in raw_data[0:2]:
		file_name = os.path.basename(file.split(".")[0]) 
		porechop = " ".join([
		"porechop",  # Call porechop to trim adapters
		"--threads", str(args.threads),  # Number of threads to be used by the script
		"--format fastq.gz",  # Output as compressed fastq files
		"--input", file,  # FASTQ of input reads
		"--output", os.path.join(prepr_dir, "{0}.tr.fastq.gz".format(file_name)),  # Filename for FASTQ of trimmed reads
		"--verbosity 2",  # Level of progress information
		"2>>", os.path.join(reports_dir, "porechop_report.txt")])
		subprocess.run(porechop, shell=True)
	return

def alignment_against_ref():
	if not os.path.exists(alignments_dir): os.makedirs(alignments_dir)

	raw_data = [sum_file for sum_file in glob.glob(os.path.join(raw_data_dir, "fastq_pass/*.fastq.gz"))]
	sample_id = raw_data_dir.split("/")[4].split("_")[-1]

	for files in raw_data[0:1]:
		file_name = os.path.basename(files.split(".")[0])
		minimap2_genome = " ".join([
		"~/playground/progs/minimap2-2.17_x64-linux/minimap2",  # Call minimap2 (v2.17-r941)
		"-t", str(args.threads),  # Number of threds to use
		"-ax splice",   # Long-read spliced alignment mode and output in SAM format (-a)
		"-k 14",  # Output at most 10 secondary alignments
		"-uf",  # Find canonical splicing sites GT-AG - f: transcript strand
		"--secondary=no",
		"-o", os.path.join(alignments_dir, "{0}.genome.paf".format(file_name)),
		refGenomeGRCh38,  # Inputting the reference genome
		files,  # Input .fastq.gz file
		"|", "samtools view",  # Calling 'samtools view' to compress the Bowtie's output file to BAM
  		"--threads", str(args.threads),  # Number of threads to be used by Samtools in the conversion of the SAM files to BAM
  		"-S -u1",  # Input format is auto-detected, the output file should be in BAM format, and use fast compression
  		"-",  # Piping the input file
  		"|", "samtools sort",  # Calling 'samtools sort' to sort the output alignment file
  		"--threads", str(args.threads),  # Number of threads to be used by 'samtools sort'
  		"-o", os.path.join(alignments_dir, "{0}.genome.bam".format(file_name)), "-",  # Sorted output  BAM file
		"2>>", os.path.join(reports_dir, "minimap2_genome_report.txt")])  # Directory where all FastQC and Cutadapt reports reside
		subprocess.run(minimap2_genome, shell=True)


		minimap2_transcriptome = " ".join([
		"~/playground/progs/minimap2-2.17_x64-linux/minimap2",  # Call minimap2 (v2.17-r941)
		"-t", str(args.threads),  # Number of threds to use
		"-ax splice",   # Long-read spliced alignment mode and output in SAM format (-a)
		"--splice-flank=no",  # Enable the splice alignment mode
		"--secondary=no",  # Higher junction accuracy
		"-o", os.path.join(alignments_dir, "{0}._transcriptome.paf".format(file_name)),
		refTranscGRCh38,  # Inputting the reference genome
		files,  # Input .fastq.gz file
		"|", "samtools view",  # Calling 'samtools view' to compress the Bowtie's output file to BAM
  		"--threads", str(args.threads),  # Number of threads to be used by Samtools in the conversion of the SAM files to BAM
  		"-S -u1",  # Input format is auto-detected, the output file should be in BAM format, and use fast compression
  		"-",  # Piping the input file
  		"|", "samtools sort",  # Calling 'samtools sort' to sort the output alignment file
  		"--threads", str(args.threads),  # Number of threads to be used by 'samtools sort'
  		"-o", os.path.join(alignments_dir, "{0}.transcriptome.bam".format(file_name)), "-",  # Sorted output  BAM file
		"2>>", os.path.join(reports_dir, "minimap2_transcriptome_report.txt")])  # Directory where all FastQC and Cutadapt reports reside
		subprocess.run(minimap2_transcriptome, shell=True)
	return

def mapping_qc():

	genome_alignments = [sum_file for sum_file in glob.glob(os.path.join(alignments_dir, "*.genome.bam"))]
	nanoPlot_gn = " ".join([
	"NanoPlot",  # Call pycoQC
	"--threads", str(args.threads),  # Number of threads to be used by the script
	"--bam", genome_alignments,  # Input bam files
	"--color saddlebrown",  # Color for the plots
	"--colormap PuBuGn",  # Colormap for the heatmap
	"--prefix", os.path.join(reports_dir, "{0}_".format(sample_id)),  # Create the report in the reports directory
	"--format png",  # Output format of the plots
	"--dpi 900", # Set the dpi for saving images in high resolution
	"2>>", os.path.join(reports_dir, "nanoPlot_gnQC_alignment_report.txt")])
	# subprocess.run(nanoPlot_gn, shell=True)
	
	# transcriptome_alignments = " ".join([sum_file for sum_file in glob.glob(os.path.join(alignments_dir, "*.transcriptome.bam"))])
	# nanoPlot_tr = " ".join([
	# "NanoPlot",  # Call pycoQC
	# "--threads", str(args.threads),  # Number of threads to be used by the script
	# "--bam", transcriptome_alignments,  # Input bam files
	# "--color saddlebrown",  # Color for the plots
	# "--colormap PuBuGn",  # Colormap for the heatmap
	# "--prefix", os.path.join(reports_dir, "{0}_".format(sample_id)),  # Create the report in the reports directory
	# "--format png",  # Output format of the plots
	# "--dpi 900", # Set the dpi for saving images in high resolution
	# "2>>", os.path.join(reports_dir, "nanoPlot_trQC_alignment_report.txt")])
	# subprocess.run(nanoPlot_tr, shell=True)
	return

def main():
	
	# quality_control()

	# preprocessing_raw_data()

	alignment_against_ref()

	# mapping_qc()

if __name__ == "__main__": main()